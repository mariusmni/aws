<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Personalize AWS RunCommand by mariusmni</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/github-dark.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>Personalize AWS RunCommand</h1>
        <p>How to personalize command to behave differently depending on instance</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/mariusmni/aws" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/mariusmni/aws/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/mariusmni/aws/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h3>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span class="octicon octicon-link"></span></a>Introduction</h3>

<p>If you are familiar with the Message Passing Interface (MPI) for parallel computation, you know that we run the same code on multiple processors. However, the code can behave differently on different processor because each processor has an index. For example, if the processor index is 0 we can act as a master, otherwise as a slave.</p>

<p>This page explains how to emulate the MPI behaviour on <a href="https://aws.amazon.com/ec2/run-command/">AWS RunCommand</a>. In other words, we want to run the same script on a fleet of EC2 instances, but the script behaves differently depending on an instance index. The next section explains how to obtain an instance index.</p>

<h3>
<a id="how-to-assign-a-unique-index-to-every-instance" class="anchor" href="#how-to-assign-a-unique-index-to-every-instance" aria-hidden="true"><span class="octicon octicon-link"></span></a>How to assign a unique index to every instance</h3>

<p>Say we have a fleet of linux instances. Every instance in the fleet has an instance ID, which is a string. The instance ID can be retrieved from METADATA as follows:</p>

<p><code>
curl -s http://169.254.169.254/latest/meta-data/instance-id
</code></p>

<p>The output will be something like this:</p>

<p><code>
i-67a6a8a3
</code></p>

<p>However, for our purpose, instead of a string we want an index between 0 and size of the fleet - 1. A simple way to do this is to create a script, say number.sh, which simply does </p>

<p><code>
echo &lt;index&gt;
</code></p>

<p>Where index differs from instance to instance. Of course, we can manually create this script on every instance, since this is a one time operation. However, for a large fleet, it is easier to use RunCommand itself to generate the number.sh script. </p>

<p>Assume we have two instances:</p>

<pre><code>i-67a6a8a3
i-cea5ab0a
</code></pre>

<p>We can run the following through RunCommand to generate the number.sh script:</p>

<pre><code>#!/bin/bash

# mapping between instance ID and index
declare -A num
num=(
  [i-67a6a8a3]=0
  [i-cea5ab0a]=1
)

# get instance ID of the current instance
instanceID="`curl -s http://169.254.169.254/latest/meta-data/instance-id`"

# get index for the current instance
index=${num[$instanceID]}

# generate number.sh script and make it executable
echo "echo $index" &gt; /number.sh
chmod +x /number.sh
</code></pre>

<p>To test that the script was generated, we can run it via RunCommand:</p>

<p><code>
/number.sh
</code></p>

<p>The outputs should be 0 or 1 depending on the instance.</p>

<h3>
<a id="example-on-how-to-personalize-command-based-on-index" class="anchor" href="#example-on-how-to-personalize-command-based-on-index" aria-hidden="true"><span class="octicon octicon-link"></span></a>Example on how to personalize command based on index</h3>

<p>For this example we will clone the git project <a href="https://github.com/mariusmni/qpms9">qpms9</a> which solves the <a href="https://en.wikipedia.org/wiki/Planted_motif_search">Planted Motif Search</a> problem. The problem itself is not important for our discussion. The project comes with a dataset generator. We will use the generator to create different datasets depending on the instance index. Then we will solve the problem on each dataset.</p>

<p>To get and build the program we have to run the following via RunCommand. For working dir use <code>/tmp</code>.</p>

<pre><code>git clone https://github.com/mariusmni/qpms9.git
cd qpms9
make -C qpms9 nompi
make -C qpms9-data
</code></pre>

<p>The above assumes that you have <code>git</code>, <code>make</code> and <code>g++</code> installed. You can install them using something like </p>

<pre><code>sudo apt-get install git make g++
</code></pre>

<p>on ubuntu, or</p>

<pre><code>sudo yum install git make gcc-c++
</code></pre>

<p>on amazon linux/redhat.</p>

<p>Finally, we can now generate a dataset and solve it. The dataset will use the instance index as a random number generator seed. This way, every instance generates a unique dataset. Execute the following via RunCommand, with the same working dir <code>/tmp</code>:</p>

<pre><code>cd qpms9
mkdir results
n=`/number.sh`
qpms9-data/Release/qpms9-data  -l 13 -d 4 -r $n -o results/t13,4-$n.in
qpms9/NoMpi/qpms9 results/t13,4-$n.in -l 13 -d 4 i -o results/t13,4-$n.out
</code></pre>

<p>Notice the</p>

<pre><code>n=`/number.sh`
</code></pre>

<p>This sets the variable <code>n</code> to the index of the instance. The index is then passed to the dataset generator as a random number generator seed (<code>-r $n</code>) and is also used to generate the names of the input/output (<code>t13,4-$n.in</code>, <code>t13,4-$n.out</code>) files.</p>

<p>We can now save our results to amazon s3 via the following RunCommand:</p>

<pre><code>aws s3 sync qpms9/results s3://mariusmni-bucket/qpms
</code></pre>

<p>The bucket location should contain:</p>

<pre><code>t13,4-0.in
t13,4-0.out
t13,4-1.in
t13,4-1.in
</code></pre>

<p>which are the input and output files from our mini fleet.</p>

<p>The above command requires the <a href="http://docs.aws.amazon.com/cli/latest/userguide/installing.html">AWS CLI</a> to be installed.</p>

<h3>
<a id="conclusion" class="anchor" href="#conclusion" aria-hidden="true"><span class="octicon octicon-link"></span></a>Conclusion</h3>

<p>This tutorial shows how to run commands on a fleet of instances such that a single command can behave differently depending on the instance. We achieve this by assigning a unique numerical index for each instance. This index can be used to personalize the command, similar to MPI code.</p>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/mariusmni">mariusmni</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
