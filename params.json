{"name":"Personalize AWS RunCommand","tagline":"How to personalize command to behave differently depending on instance","body":"### Introduction\r\nThis page explains how to run a single AWS RunCommand on multiple instances, the command behaving differently on each instance.\r\n\r\nIf you are familiar with the Message Passing Interface (MPI) for parallel computation, you know that we run a single piece of code on all the processors. However, each processor has an index, therefore the code can execute differently depending on the processor index. For example, processor 0 can act as a master, and the rest as slaves.\r\n\r\nWe want to emulate this behaviour for AWS RunCommand, namely, we want to execute a single script on a fleet of instances, but the actual code executed to differ depending on the instance. In other words, we want each instance to have an index.\r\n\r\nIn the next section we make each instance have an index, then we go through an actual example of how the index can be used.\r\n\r\n### How to assign an index to every instance\r\n\r\nSay you have a fleet of linux instances. Every instance has an instance ID, which is a string. The instance ID can be retrieved from METADATA as follows:\r\n\r\n`\r\ncurl -s http://169.254.169.254/latest/meta-data/instance-id\r\n`\r\n\r\nThe output will be something like this:\r\n\r\n`\r\ni-67a6a8a3\r\n`\r\n\r\nHowever, for our purpose, we want to obtain an index number between 0 and size of the fleet - 1. A simple way to do this is to create a script, say number.sh, which simply does \r\n\r\n`\r\necho <number>\r\n`\r\n\r\nWhere number differs from instance to instance. Of course we can manually create this script on every instance, but we can also use RunCommand to generate the script, as follows. Assume we have two instances:\r\n\r\n```\r\ni-67a6a8a3\r\ni-cea5ab0a\r\n```\r\n\r\nWe can run the following command to generate the number script:\r\n\r\n```\r\n#!/bin/bash\r\n\r\n# mapping between instance ID and index\r\ndeclare -A num\r\nnum=(\r\n  [i-67a6a8a3]=0\r\n  [i-cea5ab0a]=1\r\n)\r\n\r\n# get instance ID of the current instance\r\ninstanceID=\"`curl -s http://169.254.169.254/latest/meta-data/instance-id`\"\r\n\r\n# get index for the current instance\r\nindex=${num[$instanceID]}\r\n\r\n# generate number.sh script and make it executable\r\necho \"echo $index\" > /number.sh\r\nchmod +x /number.sh\r\n```\r\n\r\nTo test that the script was generated, we can run it, again using RunCommand:\r\n\r\n`\r\n/number.sh\r\n`\r\n\r\nThe outputs should be 0 or 1 depending on the instance.\r\n\r\n### Example on how to use the index\r\n\r\nFor this example we will clone the git project [qpms9](https://github.com/mariusmni/qpms9) which is a project for the [Planted Motif Search](https://en.wikipedia.org/wiki/Planted_motif_search) problem. The problem itself is not important for our discussion. What matters is that the project comes with a dataset generator. We will use the generator to create different datasets depending on the instance. Then each instance will solve the problem on its dataset.\r\n\r\nTo get and build the program we have to run the following via RunCommand:\r\n\r\n```\r\ngit clone https://github.com/mariusmni/qpms9.git\r\ncd qpms9\r\nmake -C qpms9 nompi\r\nmake -C qpms9-data\r\n```\r\n\r\nwith working dir `/tmp`\r\n\r\nThe above assumes that you have git, make and g++ installed. If not, you have to install them first using something like \r\n\r\n``` \r\nsudo apt-get install git make g++\r\n```\r\non ubuntu, or\r\n\r\n```\r\nsudo yum install git make gcc-c++\r\n```\r\n\r\non amazon linux/redhat.\r\n\r\nFinally, we can generate a dataset and solve it. Run the following via RunCommand:\r\n\r\n```\r\ncd qpms9\r\nmkdir results\r\nn=`/number.sh`\r\nqpms9-data/Release/qpms9-data  -l 13 -d 4 -r $n -o results/t13,4-$n.in\r\nqpms9/NoMpi/qpms9 results/t13,4-$n.in -l 13 -d 4 i -o results/t13,4-$n.out\r\n```\r\n\r\nwhere the working dir is `/tmp`.\r\n\r\nNotice the \r\n```\r\nn=`/number.sh`\r\n```\r\n\r\nThis sets the variable n to the index of the instance. The index is then passed to the dataset generator as a random number generator seed (`-r $n`) and is also used in the names of the input/output files.\r\n\r\n\r\nWe can now save our results to amazon s3 via the following RunCommand command:\r\n\r\n```\r\naws s3 sync qpms9/results s3://mariusmni-bucket/qpms\r\n```\r\nThe bucket location should contain:\r\n\r\n```\r\nt13,4-0.in\r\nt13,4-0.out\r\nt13,4-1.in\r\nt13,4-1.in\r\n```\r\n\r\nwhich are the input and output files from our entire fleet.\r\n\r\nThe above command requires the [AWS CLI](http://docs.aws.amazon.com/cli/latest/userguide/installing.html) to be installed.\r\n\r\n\r\n### Conclusion\r\n\r\nThis tutorial shows how to run commands on a fleet of instances such that a single command can behave differently depending on the instance. We achieve this by assigning a unique numerical index for each instance, similar to how processors are assigned indices in MPI.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}