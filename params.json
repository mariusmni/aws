{"name":"Personalize AWS RunCommand","tagline":"How to assign numeric rank to instances in a fleet so that commands can behave differently depending on instance rank (similar to how MPI code can behave differently based on processor rank)","body":"### Introduction\r\n\r\n[Amazon EC2 RunCommand](https://aws.amazon.com/ec2/run-command/) is a feature that allows you to manage a fleet of amazon instances by automating common administrative tasks like executing Shell scripts and commands on Linux. This is great if you want to run the same command on all the instances. However, one may want to run commands that behave differently depending on the instance. For example, if you want to process certain datasets in parallel, you probably want every instance to process a different dataset. This idea is not new to parallel processing. For example, the [Message Passing Interface (MPI)](https://en.wikipedia.org/wiki/Message_Passing_Interface) allows each processor to have a different behaviour depending on a processor rank or index. \r\n\r\nThis page explains how to emulate the MPI behaviour on [AWS RunCommand](https://aws.amazon.com/ec2/run-command/). In other words, we want each instance to have a numerical index. This way, we can run the same script on a fleet of EC2 instances, where the script behaves differently depending on the instance index. The instance index can be generated as follows.\r\n\r\n### How to assign a unique index to every instance\r\n\r\nAssume we have a fleet of EC2 linux instances. Every instance in the fleet already has an instance ID. The instance ID can be retrieved from METADATA as follows:\r\n\r\n`\r\ncurl -s http://169.254.169.254/latest/meta-data/instance-id\r\n`\r\n\r\nThe output will be something like this: `i-67a6a8a3`\r\n\r\nFor our purpose, we also want each instance to have an index between 0 and size of fleet - 1. A simple way to do this is to create a script, say number.sh, which does `echo <index>` where index differs from instance to instance. The script can be created manually, but for a large fleet we can use RunCommand itself to generate the `number.sh` script, as follows. \r\n\r\nAssume that our fleet has two instances:\r\n\r\n```\r\ni-67a6a8a3\r\ni-cea5ab0a\r\n```\r\n\r\nWe can execute the following through RunCommand to generate the number.sh script:\r\n\r\n```\r\n#!/bin/bash\r\n\r\n# mapping between instance ID and index\r\ndeclare -A num\r\nnum=(\r\n  [i-67a6a8a3]=0\r\n  [i-cea5ab0a]=1\r\n)\r\n\r\n# get instance ID of the current instance\r\ninstanceID=\"`curl -s http://169.254.169.254/latest/meta-data/instance-id`\"\r\n\r\n# get index for the current instance\r\nindex=${num[$instanceID]}\r\n\r\n# generate number.sh script and make it executable\r\necho \"echo $index\" > /number.sh\r\nchmod +x /number.sh\r\n```\r\n\r\nThe above script has a mapping between instance IDs and numerical indices. When it runs, it converts the instance ID to its numerical index. It then generates the number.sh script which echoes the index. The path of the script in this example is the root folder (/) for simplicity.\r\n\r\n\r\nTo test that the script was generated, we can run it via RunCommand:\r\n\r\n`\r\n/number.sh\r\n`\r\n\r\nThe outputs should be 0 or 1 depending on the instance.\r\n\r\n### How to personalize command based on index\r\n\r\nIn this section, we will fetch a program from github, generate a random dataset, then run the program on the datasets. The catch is that every dataset will be generated by using the instance index as a random number generator seed. Thus, every instance runs on a unique dataset.\r\n\r\nFor this example we will clone the git project [qpms9](https://github.com/mariusmni/qpms9) which solves the [Planted Motif Search](https://en.wikipedia.org/wiki/Planted_motif_search) problem. The problem itself is not important for our discussion. The project comes with a dataset generator. We will use the generator to create different datasets depending on the instance index. Then we will solve the problem on each dataset.\r\n\r\nThe following commands assume that you have `git`, `make` and `g++` installed. You can install them using something like \r\n``` \r\nsudo apt-get install git make g++\r\n```\r\non ubuntu, or\r\n\r\n```\r\nsudo yum install git make gcc-c++\r\n```\r\n\r\non amazon linux/redhat.\r\n\r\n\r\nTo get and build the qpms9 program we have to run the following via RunCommand. For working dir use `/tmp`.\r\n\r\n```\r\ngit clone https://github.com/mariusmni/qpms9.git\r\ncd qpms9\r\nmake -C qpms9 nompi\r\nmake -C qpms9-data\r\n```\r\n\r\nNow we generate a dataset and solve it. Execute the following via RunCommand, with the same working dir, `/tmp`:\r\n\r\n```\r\ncd qpms9\r\nmkdir results\r\nn=`/number.sh`\r\nqpms9-data/Release/qpms9-data  -l 13 -d 4 -r $n -o results/t13,4-$n.in\r\nqpms9/NoMpi/qpms9 results/t13,4-$n.in -l 13 -d 4 i -o results/t13,4-$n.out\r\n```\r\n\r\nNotice the\r\n\r\n```\r\nn=`/number.sh`\r\n```\r\n\r\nThis sets the variable `n` to the index of the instance. The index is then passed to the dataset generator as a random number generator seed (`-r $n`) and is also used to generate the names of the input/output (`t13,4-$n.in`, `t13,4-$n.out`) files.\r\n\r\n\r\nIf we have the [AWS CLI](http://docs.aws.amazon.com/cli/latest/userguide/installing.html)installed, we can save our results to amazon s3 via the following RunCommand:\r\n\r\n```\r\naws s3 sync qpms9/results s3://mariusmni-bucket/qpms\r\n```\r\n\r\nThe bucket location will contain the input and output files from our entire fleet:\r\n\r\n```\r\nt13,4-0.in\r\nt13,4-0.out\r\nt13,4-1.in\r\nt13,4-1.in\r\n```\r\n\r\n\r\n### Conclusion\r\n\r\nThis tutorial showed how to run commands on a fleet of EC2 instances such that a single command behaves differently depending on the instance. We achieved this by assigning a unique numerical index for each instance. This index can be used to personalize the command, similar to how we can personalize MPI code. The above was tested on an Amazon Linux and an Ubuntu instances, but the principle can be applied on any fleet, including a mixed linux/windows fleet.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}